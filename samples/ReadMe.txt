Genetic Algorithm Framework and Sample Client 

The zujkomiller.genetic package and its subpackages contain a framework of classes written in java for performing genetic algorithms.  The zujkomiller.maze package and its subpackages contain a client of that framework which uses genetic algorithms to find the best solution to a maze.


Brief Introduction to Genetic Algorithms

A genetic algorithm mimics the process of biological evolution in order to find a solution to a problem.  In nature, the "problem" is survival, and the "solution" is to create individuals with traits which enable them to survive and reproduce, thereby passing on the genes which make them fit. In nature, chromosomes of DNA molecules carry the genes which become expressed as traits.  In a computer program the "problem" can be anything, and the program designer can choose what it means for a solution to be "good" or "fit".

As in nature, a genetic algorithm deals with chromosomes.  These are usually strings of characters, or "genes".  In DNA, they are A, T, C, and G, but in a genetic algorithm they may be either binary (containing only ones and zeros), or larger (containing more than two symbols in its alphabet of possible genes).  Just as in nature, a genetic algorithm will start with a randomly created "generation" or set of chromosomes, each with a slightly different configuration.  Then, each individual in that generation is put through some test of fitness which the programmer devises.  The fitness test should reflect how well the chromosome represents the solution to the programmer's problem.  After being tested for fitness, a child generation is created from the parent: the least fit members of the parent generation are thrown out; the most fit members are cloned and "mated" with one another; and a few random mutations are added to the mix. After many generations, better and better solutions to the problem emerge because the genes that make them good solutions are selected-for through this process of creating child generations from the most fit members of the parent generation.

Finding a solution to a maze is an example of a problem which can be solved with a genetic algorithm.  The maze itself consists of a starting grid, an end-point, and some walls.  The solution to the maze can be represented as a list of directions in which to step, starting at the beginning, avoiding the walls, and ending at the end-point.  The "genes" would be "N" (step to the north), "S" (step to the south), "E" (step to the east), and "W" (step to the west).  So, a chromosome may look something like, "N, N, E, S, W, W, S, E, N".  The most-fit solution would be one with the fewest number of steps taken to reach the end-point of the maze.


How to Run the Maze Sample Client

All clients of the framework must create a .properties file which specifies the parameters for running the genetic algorithm.  These include: the number of generations to run, the number of individuals per generation, the number of mutations and crossovers to create in each generation, etc.  See the MazeGenetic.properties file for an example of each of these parameters.  Comments in that file indicate the meaning of each. Once the .properties file has been created, the location of that file is passed as a command-line argument to the zujkomiller.genetic.client.Genie program.  

To run the Maze sample client program, first be certain to include the genetic.jar and maze.jar in your classpath variable, and then simply run the solvemaze.bat file (in the bin directory) which contains the command, "java zujkomiller.genetic.client.Genie ../../maze/bin/MazeGenetic.properties".  This will produce some output to the console screen as the program runs, and will also write output to maze\output\difficult.txt.

After running maze.bat, open the Maze program by running maze.bat. Under the tools menu, select Results Displayer.  Select File/Open and choose the results file to open.  This will open the index pane which shows a Tree listing every 5th Generation that was created when the genetic algorithm was run.  Within each Generation, individual solutions are grouped by the fitness score they received.  Double-click on any solution file to see a graphical representation of how well that solution solved the maze.  The red line shows that path that was taken to solve the maze, and the "Directions Traveled" box at the bottom of the screen lists the moves that were taken to create the path.  To watch how the path was created, select the "Animate" or "Step" buttons beneath the maze. "Animate" shows a red dot taking each of the steps until the path is completed.  "Step" allows you to move the dot one grid at a time to the end of the path. You may also select the speed at which the animation or stepping should occur.  Selecting View/Scoring Rules from the menu bar will show a box explaining how the fitness scores were derived.